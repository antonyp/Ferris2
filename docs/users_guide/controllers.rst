Controller
==========

.. module:: ferris.core.controller

Controllers are responsible for processing and responding to HTTP requests. Controllers are typically lightweight classes that glue the :doc:`models` to the :doc:`templates`. Controllers can be extended with :doc:`components` and :doc:`scaffolded <scaffold>`.

    .. autoclass:: Controller()

Conventions
-----------

Controllers are named plural nouns in upper camel case (UpperCamelCase) from the models that they are associated with (for example: Pages, Users, Images, Bears, etc.). The are many cases where the plural convention doesn't make sense, such as controllers that don't have an associated model or controllers that span multiple models.

Each controller class should be in its own file under ``/app/controllers`` and the name of the file should be the underscored class name. For example, to create a controlller to act on fuzzy bears, you would create the file ``/app/controller/fuzzy_bears.py`` and inside of that define a class named ``FuzzyBears``.

This section mostly focuses on actions and how to process and respond to requests. Other features are tied into controllers in various ways. Controller actions are exposed via the :doc:`routing` system. Controllers can automatically discover and determine which :doc:`template <templating>` to use and render it. Controllers can process POST and JSON data and attach it to :doc:`forms`. Controllers also allow you to break out common functionality using :doc:`components`.


Meta
----

    .. autoclass:: ferris.core.controller::Controller.Meta()
        :members:

Util
----

    .. autoclass:: ferris.core.controller::Controller.Util()
        :members:

Actions
-------

Actions are normal instance methods that can be invoked via HTTP. Ferris takes care of :doc:`automatically routing <routing>` actions and generating URLS.


Requests
--------

Actions can access the current request using ``self.request``::

    def list(self):
        return self.request.path

For more information on the request object see the `webapp2 documentation on requests <http://webapp-improved.appspot.com/guide/request.html>`_.

Data
~~~~

Actions can also access the GET and POST variables using ``self.request.params``::

    def list(self):
        return self.request.params['text']

For just GET variables use ``self.request.GET``, and for POST only use ``self.request.POST``.

Parameters
~~~~~~~~~~~

Actions can also take various parameters on the URL as described in :doc:`routing`::

    def list(self, text, number):
        return text + str(number)

User & Session
~~~~~~~~~~~~~~

.. autoattribute:: Controller.user

.. autoattribute:: Controller.session
    
Route Info
~~~~~~~~~~

.. attribute:: Controller.route.action
    
    The current action, such as 'add', 'list', 'edit', etc.

.. attribute:: Controller.route.prefix

    The current prefix, such as None, 'admin', 'api', etc.

.. attribute:: Controller.route.controller

    The current controller's name.

.. attribute:: Controller.route.name

    The canonical route name, as generated by :ref:`routing-url-and-name-generation`.

Response
--------

Actions can access the current response using ``self.response``::

    def list(self):
        self.response.write('hi')
        return self.response

For more information on the request object see the `webapp2 documentation on responses <http://webapp-improved.appspot.com/guide/response.html>`_.

Return Values
~~~~~~~~~~~~~

Actions can return a string and the string will become the body of the response::

    def list(self):
        return 'Hi!'

Actions can return an integer and the will become the status of the response, in this case the response will be a `404 Not Found`::

    def list(self):
        return 404

Actions can return any ``webapp2.Response`` class, including ``self.response``::

    def list(self):
        self.response.content_type = 'text/json'
        self.response.text = '[0,1,2]'
        return self.response

Even if you return a string or integer, any changes to ``self.response`` are kept (except for the body or status, respectively)::

    def list(self):
        self.response.content_type = 'text/html'
        return '<h1>Hello!</h1>'

Returning nothing (``None``) will trigger the automatic view rendering unless ``self.meta.view.auto_render`` is set to ``False``::

    def list(self):
        pass
        # Return nothing will cause /app/templates/[controller]/list.html to be loaded and rendered.

Redirection
~~~~~~~~~~~

Redirects can be generated using :meth:`redirect` and :meth:`~ferris.core.controller.Controller.uri`::
    
    @route
    def auto(self):
        return self.redirect(self.uri(action='exterminate', who='everything'))


Template Rendering
------------------

Handler contains a bit of logic to make rendering templates easier. By default, returning ``None`` from an action will trigger automatic template rendering. You can easily pass data from the handler to the template and control how the handler finds its template.

View Context
~~~~~~~~~~~~

To provide data to the view use the :attr:`context` property:

    .. autoattribute:: Controller.context

For example::

    def list(self):
        self.context['band'] = "The Beatles"
        self.context['members'] = ['John', 'Paul', 'George', 'Ringo']

Determination
~~~~~~~~~~~~~

A Handler can automatically determine which template to use:

.. automethod:: Handler._get_template_name

If you're not serving up html, you can change the extension:

.. autoattribute:: Handler.template_ext

If you'd like to use a theme:

.. autoattribute:: Handler.theme

If you set ``template_name`` to the full path of the template that will be used instead of the result of :meth:`~Handler._get_template_name`. This allows you to use templates from other actions and even other handlers:

.. autoattribute:: Handler.template_name

For example::

    def list(self):
        self.template_name = 'shows/grid.html'


Rendering
~~~~~~~~~

By default, :attr:`auto_render` is enabled:

.. autoattribute:: Handler.auto_render

Of course, you can also manually render a template:

.. automethod:: Handler.render_template

For example::

    def list(self):
        return render_template('planets/earth.html')


JSON
----

Handler provides a built-in method for JSON encoding python objects:

.. automethod:: Handler.json

This can be used to respond to requests with JSON data easily::

    def numbers(self):
        return self.json(range(0,100))

.. note::
    You will have to set the ``content-type`` header to ``application/json`` manually. If many actions are responding with JSON, you can set this header in the :meth:`~Handler.startup` callback.


Keys
----

When passing ndb.Keys in parameters or URLs, use the following methods to encode & decode them:

    .. method:: Controller.util.decode_key(urlsafe)

        Essentially the same as ``ndb.Key(urlsafe=urlsafe)``

    .. method:: Controller.util.encode_key(key)

        Essentially the same as ``key.urlsafe()`` or if key is a Model instance, ``model.key.urlsafe()``

For example::
    
    @route
    def one(self):
        item = Widget.find_by_name('screwdriver')
        return self.redirect(
            self.uri(action='two', id=self.util.encode_key(item)))

    @route
    def two(self, id):
        item = self.util.decode_key(id).get()
        return item.name


The Startup Method and Events
-----------------------------

Handlers have various events that are called during the lifecycle of a request. Event handlers are mostly commonly registered at the beginning
of a request using the startup callback method.

    .. automethod:: Controller.startup()

You can tap into these events using :attr:`Controller.events` which is a :class:`~ferris.core.event.NamedEvents` instance::

    def startup(self):
        self.events.before_dispatch += self.on_after_dispatch

Events
~~~~~~

For a usual request, the events in order are:

#. setup_template_variables
#. before_build_components, after_build_components
#. before_startup, after_startup
#. before_dispatch, after_dispatch
#. template_names (only if using :class:`~ferris.core.views.TemplateView`)
#. before_render, after_render (only if a view is rendered)
#. dispatch_complete

These events are broadcasted to the global event bus with the prefix ``controller_``.